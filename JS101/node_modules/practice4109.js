"use strict";

// const obj = {
//   text: "Remove occurances of the letter e after the word 'letter' in this sentence",
// };
// Object.freeze(obj);

// /**
//  * BONUS:
//  * A single function should satisfy the strings defined 'obj' and the bonus objects below
//  * The function should only take a single argument of type object
//  * The function should be able to accomidate any word between the single quotes
//  */
// const bonusObj1 = {
//   text: "Remove occurances of the letter e after 'the' in this sentence",
// };
// const bonusObj2 = {
//   text: "The letter e should not appear after the word 'not' in this sentence",
// };
// Object.freeze(bonusObj1);
// Object.freeze(bonusObj2);

// function forSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);

//   for (const char of strToChange) {
//     if (char !== "e") {
//       // console.log(char, typeof char);
//       unchangedStr += char;
//     }
//   }
//   return unchangedStr;
// }

// function whileSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);
//   let charNum = 0;

//   while (strToChange[charNum]) {
//     if (strToChange[charNum] !== "e") {
//       unchangedStr += strToChange[charNum];
//     }
//     charNum++;
//   }
//   return unchangedStr;
// }

// function doWhileSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);
//   let charNum = 0;

//   do {
//     if (strToChange[charNum] !== "e") {
//       unchangedStr += strToChange[charNum];
//     }
//     charNum++;
//   } while (strToChange[charNum]);
//   return unchangedStr;
// }

// function forEachSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);

//   strToChange.split("").forEach((char) => {
//     if (char !== "e") {
//       unchangedStr = unchangedStr.concat(char);
//     }
//   });
//   return unchangedStr;
// }

// function filterSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);

//   const strToChangeArr = strToChange.split("").filter((char) => char !== "e");
//   return unchangedStr + strToChangeArr.join("");
// }

// function mapSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);

//   const strToChangeArr = strToChange.split("").map((char) => {
//     if (char !== "e") {
//       return char;
//     }
//   });
//   return unchangedStr + strToChangeArr.join("");
// }

// function reduceSolution(obj) {
//   const wordIdx = obj["text"].lastIndexOf("'");
//   let unchangedStr = obj["text"].slice(0, wordIdx);
//   const strToChange = obj["text"].slice(wordIdx);

//   const strToChangeArr = strToChange.split("").reduce((acc, char) => {
//     return char !== "e" ? acc + char : acc;
//   }, "");
//   return unchangedStr + strToChangeArr;
// }

// console.log(reduceSolution(obj));
// console.log(reduceSolution(bonusObj1));
// console.log(reduceSolution(bonusObj2));

// -------------------------------------------------------------------------------------------------

// function generateArr (start, finish) {
//   const range = finish - start;
//   return [...new Array(range)].map((_, idx) => idx);
// }
function generateArr (start, finish) {
  const arr = [];

  for (i = start; i <= finish; i++) {
    arr.push(i);
  }
  return arr;
}

console.log(generateArr(1, 10));
console.log(generateArr(5, 12));
console.log(generateArr(19, 25));